{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Jason Chen","url":"https://jacksonsheep.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"about/index","date":"2024-02-15T03:34:30.300Z","updated":"2024-02-15T03:34:30.300Z","comments":true,"path":"2024/02/15/about/index/","link":"","permalink":"https://jacksonsheep.github.io/2024/02/15/about/index/","excerpt":"","text":"this is personal introduction","categories":[],"tags":[]},{"title":"Hello World","slug":"tools/hello-world","date":"2024-02-14T02:57:02.558Z","updated":"2024-02-14T02:57:02.558Z","comments":true,"path":"2024/02/14/tools/hello-world/","link":"","permalink":"https://jacksonsheep.github.io/2024/02/14/tools/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"w3m","slug":"w3m","date":"2023-11-04T07:12:49.000Z","updated":"2024-02-14T02:57:02.558Z","comments":true,"path":"2023/11/04/w3m/","link":"","permalink":"https://jacksonsheep.github.io/2023/11/04/w3m/","excerpt":"","text":"install step apt install w3m w3m-image -y user param enter enter the linkQ exit the session","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://jacksonsheep.github.io/tags/tool/"}]},{"title":"w3m","slug":"tools/w3m","date":"2023-11-02T16:00:00.000Z","updated":"2024-02-14T02:57:02.558Z","comments":true,"path":"2023/11/03/tools/w3m/","link":"","permalink":"https://jacksonsheep.github.io/2023/11/03/tools/w3m/","excerpt":"","text":"安装方式 apt list|grep w3m apt install w3m -y 显示方式 表格输入为红色，内嵌图像为绿色，链接为蓝色。 右键打开菜单，完成各项操作 使用方式 关键字 含义 enter 进入链接 ctrl+c 结束当前网页加载 q 退出程序","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://jacksonsheep.github.io/tags/tool/"},{"name":"termux","slug":"termux","permalink":"https://jacksonsheep.github.io/tags/termux/"}]},{"title":"ssh-nopasswd","slug":"tools/ssh-nopasswd","date":"2023-01-07T01:19:47.000Z","updated":"2024-02-14T02:57:02.558Z","comments":true,"path":"2023/01/07/tools/ssh-nopasswd/","link":"","permalink":"https://jacksonsheep.github.io/2023/01/07/tools/ssh-nopasswd/","excerpt":"","text":"ssh 客户端端执行 ssh-keygen 生成公钥和私钥到~&#x2F;.ssh 具体文件为 ~&#x2F;.ssh&#x2F;id_rsa(私钥) ~&#x2F;.ssh&#x2F;id_rsa.pub（公钥） ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub &#x72;&#x6f;&#111;&#116;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#50;&#51;&#x35;&#x2e;&#50;&#x32; 上传公钥到ssh服务器，指定服务器ip和ssh用户名 ssh &#114;&#111;&#x6f;&#x74;&#64;&#x31;&#57;&#50;&#46;&#x31;&#x36;&#56;&#46;&#50;&#x33;&#53;&#46;&#x32;&#x32; 执行免密登陆","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://jacksonsheep.github.io/tags/tool/"},{"name":"ssh","slug":"ssh","permalink":"https://jacksonsheep.github.io/tags/ssh/"}]},{"title":"data-manage","slug":"data-manage","date":"2022-07-05T16:00:00.000Z","updated":"2024-02-14T02:57:02.554Z","comments":true,"path":"2022/07/06/data-manage/","link":"","permalink":"https://jacksonsheep.github.io/2022/07/06/data-manage/","excerpt":"","text":"mysql关键字列举SELECT FROM WHERE LIMIT GROUP BY ORDER BY SET常用操作 查询当分页查询时，采用两次查询的方式，即第一次查询当前页的序号，第二次根据序号查找对应数据。这种方式主要用于单条数据较大且数据条很多的情况下对数据库查询的优化。还有一种方式是在表中添加索引，利用MySql本身机制提升查询效率。 表格 建表 修改表结构 删表 数据库 建库 删库 常用问题 忘记密码","categories":[],"tags":[{"name":"basic","slug":"basic","permalink":"https://jacksonsheep.github.io/tags/basic/"},{"name":"database","slug":"database","permalink":"https://jacksonsheep.github.io/tags/database/"}]},{"title":"design-mode","slug":"design-model","date":"2022-07-05T16:00:00.000Z","updated":"2024-02-14T02:57:02.554Z","comments":true,"path":"2022/07/06/design-model/","link":"","permalink":"https://jacksonsheep.github.io/2022/07/06/design-model/","excerpt":"","text":"设计模式 来源：菜鸟教程创建型——创建对象的同时隐藏创建逻辑的方式。程序在判断针对某个给定实力需要创建哪些对象更加灵活。 单例：Singleton：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 解决：当您想控制实例数目，节省系统资源，一个全局使用的类频繁地创建与销毁。 优点：1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 工厂：Factory：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行 解决：明确地计划不同条件下创建不同实例，接口选择的问题。 优点：1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 抽象工厂：Abstract Factory：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。创建对应工厂，工厂依据工厂模式创建对象 解决：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。接口选择的问题。 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 建造者: Builder：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 解决：在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。一些基本部件不会变，而其组合经常变化的时候。 优点：1、建造者独立，易扩展。 2、便于控制细节风险。 缺点：、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。 原型：Prototype：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 解决：在运行期建立和删除原型。利用已有的一个原型对象，快速地生成和原型对象一样的实例。 优点：1、性能提高。 2、逃避构造函数的约束。 缺点：1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 结构型——关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式 适配器：Adapter：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。 优点：1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。 缺点：1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 桥接：Bridge：将抽象部分与实现部分分离，使它们都可以独立的变化。 解决：有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。实现系统可能有多个角度分类，每一种角度都可能变化 优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。 缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 过滤器：Filter：使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。它结合多个标准来获得单一标准。 组合：Composite：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。1、您想表示对象的部分-整体层次结构（树形结构）2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 优点：1、高层模块调用简单。 2、节点自由增加。 缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。 装饰器：Decorator：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。在不想增加很多子类的情况下扩展类。 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：多层装饰比较复杂。 外观：Facade：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。 优点：1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。 缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。 享元：Flyweight：运用共享技术有效地支持大量细粒度的对象。在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。 解决：1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。 优点：大大减少对象的创建，降低系统的内存，使效率提高。 缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。 代理：Proxy：为其他对象提供一种代理以控制对这个对象的访问。 解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 优点：1、职责清晰。 2、高扩展性。 3、智能化。 缺点：1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 行为型——关注对象间通信 责任链：Chain of Responsibility：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。在处理消息的时候以过滤很多道。 优点：1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。 缺点：1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。 命令：Command：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。 解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。 缺点：使用命令模式可能会导致某些系统有过多的具体命令类。 解释器：Interpreter：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 解决：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 优点：1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。 缺点：1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。 迭代：Iterator：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 解决：不同的方式来遍历整个整合对象。 优点：1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 中介者：Mediator：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。 优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。 缺点：中介者会庞大，变得复杂难以维护。 备忘录：Memento：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 解决：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 观察者：Observer：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 优点：1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。 缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 状态：State：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 优点：1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 空对象：Null：Object创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方 策略：Strategy：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点：1、策略类会增多。 2、所有策略类都需要对外暴露。 模板：Template：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 解决：一些方法通用，却在每一个子类都重新写了这一方法。 优点：1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 访问者：Visitor：主要将数据结构与数据操作分离。 解决：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。 优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。 缺点：1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象 j2EE—— MVC：Model（模型）模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。View（视图）视图代表模型包含的数据的可视化。Controller（控制器）控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 业务代表：Business Delegate：用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。 客户端（Client）表示层代码可以是 JSP、servlet 或 UI java 代码。 业务代表（Business Delegate）一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。 查询服务（LookUp Service）查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。 业务服务（Business Service）业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。 组合实体：Composite Entity 组合实体（Composite Entity）它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。 粗粒度对象（Coarse-Grained Object）该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。 依赖对象（Dependent Object）依赖对象是一个持续生命周期依赖于粗粒度对象的对象。 策略（Strategies）策略表示如何实现组合实体。 数据访问对象：Data Access Object 数据访问对象接口（Data Access Object Interface）该接口定义了在一个模型对象上要执行的标准操作。 数据访问对象实体类（Data Access Object concrete class）该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。 模型对象&#x2F;数值对象（Model Object&#x2F;Value Object）该对象是简单的 POJO，包含了 get&#x2F;set 方法来存储通过使用 DAO 类检索到的数据。 前端控制器：Front Controller 前端控制器（Front Controller）处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。 调度器（Dispatcher）前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。 视图（View）视图是为请求而创建的对象。 拦截过滤器：Intercepting Filter 过滤器（Filter）过滤器在请求处理程序执行请求之前或之后，执行某些任务。 过滤器链（Filter Chain）过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。 Target Target 对象是请求处理程序。 过滤管理器（Filter Manager）过滤管理器管理过滤器和过滤器链。 客户端（Client）Client 是向 Target 对象发送请求的对象。 服务定位器：Service Locator 服务（Service）实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。 Context &#x2F; 初始的 Context JNDI Context 带有对要查找的服务的引用。 服务定位器（Service Locator）服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。 缓存（Cache）缓存存储服务的引用，以便复用它们。 客户端（Client）Client 是通过 ServiceLocator 调用服务的对象。 传输对象：Transfer Object 业务对象（Business Object）为传输对象填充数据的业务服务。 传输对象（Transfer Object）简单的 POJO，只有设置&#x2F;获取属性的方法。 客户端（Client）客户端可以发送请求或者发送传输对象到业务对象。 六大原则： 开闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。【需要使用接口和抽象类】 里氏代换原则：任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充 依赖倒转原则：针对接口编程，依赖于抽象而不依赖于具体 接口隔离原则：使用多个隔离的接口，比使用单个接口要好。【调降低依赖，降低耦合】 狄米特原则（最少知道）：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立 合成复用原则：尽量使用合成&#x2F;聚合的方式，而不是使用继承 （https://blog.csdn.net/fangchao2011/article/details/89203535）","categories":[],"tags":[{"name":"basic","slug":"basic","permalink":"https://jacksonsheep.github.io/tags/basic/"},{"name":"manage","slug":"manage","permalink":"https://jacksonsheep.github.io/tags/manage/"}]},{"title":"java","slug":"java","date":"2022-07-05T16:00:00.000Z","updated":"2024-02-14T02:57:02.554Z","comments":true,"path":"2022/07/06/java/","link":"","permalink":"https://jacksonsheep.github.io/2022/07/06/java/","excerpt":"","text":"Java 基础&#x3D;&#x3D; equals, hasCode，instance&#x3D;&#x3D; 两个对象的引用完全相同（即同一对象），hashCode()以C++实现，返回对象的内存地址 正则表达式https://jquery.cuishifeng.cn/regexp.htmlString类中的各种方法（matches()、replaceAll()、replaceFirst()、split()）和Pattern对象 Pattern p = Pattern.compile(``&quot;.*?(?=\\\\()&quot;``); 接口和抽象类区别接口&#x3D;规范（属性：public static final;方法：抽象方法）；抽象类&#x3D;规范+实现 接口和抽象类均可多态（父类定义，子类实现），但抽象类只能单继承，接口可以多个实现；抽象类可实例化对象，接口无构造函数，不能实例化；抽象类可以不包含抽象方法，但接口只能有抽象方法。 内部类要想访问内部类中的内容，必须通过外部类对象来实例化内部类。能够访问外部类所有的属性和方法，原理就是在通过外部类对象实例化内部类对象时，外部类对象把自己的引用传进了内部类，使内部类可以用通过Outer.this去调用外部类的属性和方法，一般都是隐式调用了，但是当内部类中有属性或者方法名和外部类中的属性或方法名相同的时候，就需要通过显式调用Outer.this了。 局部内部类是在一个方法内部声明的一个类。局部内部类中可以访问外部类的成员变量及方法。局部内部类中如果要访问该内部类所在方法中的局部变量,那么这个局部变量就必须是final修饰的 IO流（NIO，BIO，） 分类 阻塞：读写数据时客户端会发生阻塞 非阻塞 多路复用：Selector的线程不断轮询多个Socket的状态，只有在Socket有读写事件时，才会通知用户线程进行I&#x2F;O读写操作。 信号驱动：户线程发起一个I&#x2F;O请求操作时，系统会为该请求对应的Socket注册一个信号函数，然后用户线程可以继续执行其他业务逻辑；在内核数据就绪时，系统会发送一个信号到用户线程，用户线程在接收到该信号后，会在信号函数中调用对应的I&#x2F;O读写操作完成实际的I&#x2F;O请求操作 异步：类似信号驱动，但用户线程不需要关心整个I&#x2F;O操作是如何进行的，只需发起一个请求，在接收到内核返回的成功或失败信号时说明I&#x2F;O操作已经完成，直接使用数据即可。 示例 阻塞IO（BIO）:A拿着一支鱼竿在河边钓鱼，并且一直在鱼竿前等，在等的时候不做其他的事情，十分专心。只有鱼上钩的时，才结束掉等的动作，把鱼钓上来。 非阻塞IO(NIO):B也在河边钓鱼，但是B不想将自己的所有时间都花费在钓鱼上，在等鱼上钩这个时间段中，B也在做其他的事情（一会看看书，一会读读报纸，一会又去看其他人的钓鱼等），但B在做这些事情的时候，每隔一个固定的时间检查鱼是否上钩。一旦检查到有鱼上钩，就停下手中的事情，把鱼钓上来。 B在检查鱼竿是否有鱼，是一个轮询的过程。 异步IO(AIO):C也想钓鱼，但C有事情，于是他雇来了D、E、F，让他们帮他等待鱼上钩，一旦有鱼上钩，就把鱼钓上来，然后打电话给C 多路复用IO：H同样也在河边钓鱼，但是H生活水平比较好，H拿了很多的鱼竿，一次性有很多鱼竿在等，H不断的查看每个鱼竿是否有鱼上钩。增加了效率，减少了等待的时间。 信号驱动IO：G也在河边钓鱼，但与A、B、C不同的是，G比较聪明，他给鱼竿上挂一个铃铛，当有鱼上钩的时候，这个铃铛就会被碰响，G就会将鱼钓上来 NIO(非阻塞IO) Buffer为所有的原始类型提供 (Buffer)缓存支持。 Charset字符集编码解码解决方案 Channel一个新的原始 I&#x2F;O抽象，用于读写Buffer类型，通道可以认为是一种连接，可以是到特定设备，程序或者是网络的连接。 集合 Collection对集合进行排序，查找，复制等功能。（二分查找，乱序）总继承 List 有序集合 ArrayList：数组形式存储，默认长度为0，添加数据默认长度为10，长度不足时可以扩容但有最大长度限制。 LinkedList：双向链表，含有长度，头结点，尾节点三个属性，在迭代中可以添加删除数据 Vector: 线程安全的ArrayList，即当线程A使用Synchronized标记方法时，其他线程阻塞。但一般不使用，原因1. 线程并不安全，产生fail-fase错误；2. 在业务中有加锁需求，重复加锁浪费资源。 在迭代中修改数据会产生fail-fast错误。但java.util.concurrent包下的相同情况会产生fail-safe错误，其原因是对数据修改时是对原数据的副本进行修改，不影响原数据；当修改完成后将原数据指向副本。 Set 无序集合 Map 键值对 HashMap: 数组+（链表 or 红黑树） keySet():String：获取map.key的set集合 entrySet():Set：获取map关系的set集合 util StringUtil common.langhttps://www.jianshu.com/p/1886903ed14c BigDecimal 浮点数精确计算 setScale(scale, BigDecimal.ROUND_HALF_UP)：四舍五入，scale&#x3D;小数后几位？ add&#x2F;subtract 加减法 mutiply() 乘法 divide() 除法 异常多个catch：先小后大，按顺序匹配，当某一个catch匹配，跳过之后的catch，进入后续步骤。任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，编译器把finally中的return实现为一个warning。如果都有return 优先级为 final &gt; try &#x3D; catch &gt; return 反射，注解 反射：实例化对象，通过Class.forName()获取对象 注解：@Target注解目标，@Retention注解生存周期，@Documented注解文档 加密算法：AES(对称加密)，RES(非对称加密，公钥加密，私钥解密)动态加载类，jvm中需要另一个类的方法实现时，动态加入相应类 Lambda规定接口中只能有一个需要被实现的方法，不是规定接口中只能有一个方法,常与@FuncitonalInterface注解一同使用原文链接 @FunctionalInterface public interface NoReturnMultiParam &#123; void method(int a, int b); &#125; public static void main(String[] args)&#123; NoReturnNoParam noReturnNoParam = () -&gt; &#123; System.out.println(&quot;NoReturnNoParam&quot;); &#125;; noReturnNoParam.method(); &#125; native方法非Java实现的java方法。以其他语言实现的Java方法即为native方法。 jvm 堆：对象，数组 方法区（永久代）：类信息，常量，静态变量 程序计数器：当前线程执行 的字节码行号指示器 虚拟机栈：多个栈帧（局部变量表，操作数栈，动态链接表，方法出口）：java方法的执行即为栈帧的入栈，出栈 本地方法栈：类似虚拟机栈，对native方法执行出入栈操作 垃圾回收机制 识别 可达性分析算法：判断对象的引用链是否可达 引用计数算法：判断对象的引用数量，数量为零回收 回收 标记清除算法：该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收 复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 标记整理算法：标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代） 分段收集算法：不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。新生代（标记复制），老年代（标记整理，清除） 内存 新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的 老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。 永久代主要用于存放静态文件，如Java类、方法等。 回收器 Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效； Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本； ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现； Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景； Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本； CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。 G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。 原文链接 类加载（加载，链接【验证，准备，解析】，初始化，使用，卸载） 类加载器：启动类lib，扩展类jre&#x2F;lib&#x2F;ext，应用程序类classpath，自定义类 双亲委派：当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成。只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。【使用不同的类加载器最终得到的都是同样一个 Object 对象】 多线程[原文链接](https://blog.csdn.net/tanmomo/article/details/99671622) 创建线程有哪几种方式？ 继承Thread类（真正意义上的线程类），是Runnable接口的实现。 实现Runnable接口，并重写里面的run方法。 使用Executor框架创建线程池。Executor框架是juc里提供的线程池的实现。 synchronized 和 volatile 的区别是什么？ volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。 volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。 volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。 线程共享：堆，方法区（元数据）; 线程私有：程序计数器，虚拟机栈，本地方法栈 状态： 新建(New)、就绪（Runnable）start()、运行（Running）run()、阻塞(Blocked)和死亡(Dead) 数据结构Array ,ArrayListArray和ArrayList的不同点：Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。Array大小是固定的，ArrayList的大小是动态变化的。ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢 hashMap原理 哈希冲突 二叉树 红黑树 /** 以下是力扣刷题总结内容 */ /** 双指针 * 快慢指针 * 头尾指针 */ /** 二分法 —— 按条件快速查找 */ int left = 0; int right = increase.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (increase[mid] &lt; target) &#123; //不符合条件 left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left; // 符合条件元素下标 /** 分治法 —— 将复杂问题分为简单问题求解，将结果合并 */ /** 动态规划 —— 最少，最短 */ /** DFS —— 递归 */ // 广度优先遍历 Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); queue.offer(0); while (!queue.isEmpty()) &#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; // 获取当前队列中元素 int index = queue.poll(); List&lt;Integer&gt; list = edges.get(index); for (int nextIndex : list) &#123; // 添加下一层遍历得到的元素 queue.offer(nextIndex); &#125; &#125; &#125; // 深度优先遍历 public void dfs(int index) &#123; List&lt;Integer&gt; list = edges.get(index); //获取当前元素对应的下层元素 for (int nextIndex : list) &#123; // 对每个下层元素递归获取内容 dfs(nextIndex); &#125; &#125; /** 摩尔投票法 * 候选人(cand_num)初始化为nums[0]，票数count初始化为1。 * 当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。 * 当票数count为0时，更换候选人，并将票数count重置为1。 * 遍历完数组后，cand_num即为最终答案。*/ public int majorityElement(int[] nums) &#123; int cand_num = nums[0], count = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; if (cand_num == nums[i]) ++count; else if (--count == 0) &#123; cand_num = nums[i]; count = 1; &#125; &#125; return cand_num; &#125; /** 树 */ /** 中序遍历 */ public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while(cur != null || !stack.isEmpty())&#123; if(cur != null)&#123; stack.push(cur); cur = cur.left; &#125;else&#123; cur = stack.pop(); list.add(cur.val); cur = cur.right; &#125; &#125; return list; &#125; /** 前缀树 * 根节点不包含字符，除根节点外每一个节点都只包含一个字符。 * 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。 * 每个节点的所有子节点包含的字符都不相同。 * */ class Trie &#123; private Trie[] children; private boolean isEnd; public Trie() &#123; children = new Trie[26]; isEnd = false; &#125; public void insert(String word) &#123; Trie node = this; for (int i = 0; i &lt; word.length(); i++) &#123; char ch = word.charAt(i); int index = ch - &#39;a&#39;; if (node.children[index] == null) &#123; node.children[index] = new Trie(); &#125; node = node.children[index]; &#125; node.isEnd = true; &#125; public Trie[] getChildren() &#123; return children; &#125; public boolean isEnd() &#123; return isEnd; &#125; &#125; /**以下是程序员小灰学习资料自我总结内容*/ class ListNode&#123; //链表 int val; ListNode next; ListNode(int x)&#123; this.val = x;&#125; &#125; class TreeNode&#123; int val; TreeNode left; TreeNode right; &#125; class Grammer&#123; //冒泡排序 n*n public void bubbleSort(int[] arr, int n)&#123; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n-i-1; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125; //插入排序 n*n public void insertSort(int[] arr)&#123; for(int i = 1; i &lt; arr.length; i++)&#123; //要插入元素及下标 int insertVal = arr[i]; int index = i-1; while(index &gt;= 0 &amp;&amp; insertVal &lt; arr[index])&#123; arr[index+1] = arr[index]; //原来数据后移 index--; &#125; arr[index+1] = insertVal; &#125; &#125; //希尔排序 分段插入排序 略优于n*n，不足nlogn public void shellSort(int[] arr)&#123; int dk = arr.length/2; while(dk &gt;= 1)&#123; shellInsert(arr, dk); dk = dk/2; &#125; &#125; private void shellInsert(int[] arr, int dk)&#123; //类似插入，将1改为dk for(int i = dk; i &lt; arr.length; i++)&#123; if(arr[i] &lt; a[i-dk])&#123; int x = a[i]; a[i] = a[i-dk]; for(int j = i-dk; j &gt;= 0 &amp;&amp; x &lt; a[j]; j = j -dk)&#123; a[j+dk] = a[j]; &#125; a[j+dk] = x; &#125; &#125; &#125; //快速排序 递归 nlogn public void quickSort(int[] arr, int low, int high)&#123; int start = low, end = high, key = arr[low]; while(end &gt; start)&#123; while(end &gt; start &amp;&amp; arr[end] &gt;= key) //从后往前找比key小的值 end--; if(arr[end] &lt;= key)&#123; int temp = arr[end]; arr[end] = arr[start]; arr[start] = temp; &#125; while(end &gt; start &amp;&amp; arr[start] &lt;= key) //从前往后找比key大的值 start++; if(arr[start] &gt;= key)&#123; int temp = arr[start]; arr[start] = a[end]; arr[end] = temp; &#125; &#125; //左右两侧数据递归排序 if(start &gt; low) quickSort(arr, low, start-1); if(end &lt; high) quickSort(arr, end+1, high); &#125; //归并排序 nlogn jdk底层排序 public mergerSort(int[] arr, int left, int right)&#123; //初始值 0，length-1 if(left &gt;= right) return; int center(left+right)/2; //左右两侧递归排序 sort(arr,left, center); sort(arrm center+1, right); //合并 int[] tmpArr = new int[arr.length]; int mid = center+1, third = left, tmp = left;//右数组第一元素索引,临时数组索引，左数组第一元素索引 while(left &lt;= center &amp;&amp; mid &lt;= right)&#123; if(arr[left] &lt;= arr[mid])&#123; tmpArr[third++] = arr[left++]; &#125;else&#123; tmpArr[third++] = arr[mid++]; &#125; &#125; //剩余合并 while(mid &lt;= right)&#123; tmpArr[third++] = arr[mid++]; &#125; while(left &lt;= center)&#123; tmpArr[third++] = arr[left++]; &#125; //原 left-right 范围的内容被复制回原数组 while(tmp &lt;= right)&#123; arr[tmp] = tmpArr[tmp++]; &#125; &#125; //非递归前序遍历 public void preOrderTraveralWithStack(TreeNode root)&#123; Stack&lt;TreeNode&gt; stack = new Stack(); TreeNode treeNode = root; while(treeNode != null || !stack.isEmpty())&#123; //访问左侧子节点，并入栈 while(treeNode != null)&#123; System.out.println(treeNode.val); stack.push(treeNode); treeNode = treeNode.left; &#125; //如果没有左侧子节点，弹出栈顶节点，访问右侧子节点 if(!stack.isEmpty())&#123; treeNode = stack.pop(); treeNode = treeNode.right; &#125; &#125; &#125; //层序遍历 public void levelOrderTraversal(TreeNode root)&#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); System.out.println(node.val); if(node.left != null)&#123; queue.offer(node.left); &#125; if(node.right != null)&#123; queue.offer(node.right); &#125; &#125; &#125; //上浮 public void upAdjust(int[] array)&#123; int childIndex = array.length-1; int parentIndex = (childIndex-1)/2; int temp = array[childIndex]; while(childIndex &gt; 0 &amp;&amp; temp &lt; array[parentIndex])&#123; array[childIndex] = array[parentIndex]; childIndex = parentIndex; parentIndex = (parentIndex-1)/2; &#125; array[childIndex] = temp; &#125; //下沉,要下沉的父节点，堆的有效大小 public void downAdjust(int[] array, int parentIndex, int length)&#123; int temp = array[parentIndex]; int childIndex = 2*parentIndex+1; while(childIndex &lt; length)&#123; //如果有右孩子，且右孩子小于左孩子，则定位到右孩子 if(childIndex+1 &lt; length &amp;&amp; array[childIndex+1] &lt;array[childIndex])&#123; childIndex++; &#125; //如果父节点小于任何子节点 跳出循环 if(temp &lt;= array[childIndex])&#123; break; &#125; array[parentIndex] = array[childIndex]; parentIndex = childIndex; childIndex = 2*childIndex+1; &#125; &#125; //构建二叉堆 public void buildHeap(int[] array)&#123; //从最后一个非叶子节点开始下沉 for(inti = (array.length-2)/2; i &gt;= 0; i--)&#123; downAdjust(array, i, array.length); &#125; &#125; //堆排序 nlogn 255 public void downAdjusts(int[] array, int parentIndex, int length)&#123; int temp = array[parentIndex]; int childIndex = 2* parentIndex+1; while(childIndex &lt; length)&#123; if(childIndex+1 &lt; length &amp;&amp; array[childIndex+1] &lt; array[childIndex])&#123; childIndex++; &#125; if(temp &gt;= array[childIndex]) break; array[parentIndex] = array[childIndex]; parentIndex = childIndex; childIndex = 2*childIndex+1; &#125; array[parentIndex] = temp; &#125; public void heapSort(int[] array)&#123; for(int i = (array.length-2)/2; i &gt;= 0; i--)&#123; downAdjusts(array, i, array.length); &#125; //循环删除堆顶，调整产生新的堆顶 for(int i = array.length-1; i &gt; 0; i--)&#123; //首尾元素交换 int temp = array[i]; array[i] = array[0]; array[0] = temp; downAdjusts(array, 0, i); //下沉调整最大堆 &#125; &#125; //计数排序 数据在小范围内，统计个数排序 n public int[] countSort(int[] array)&#123; int max = array[0], min = array[0]; //获取最大值，最小值 for(int i = 1; i &lt; array.length; i++)&#123; if(array[i] &gt; max)&#123; max = array[i]; &#125; if(array[i] &lt; min)&#123; min = array[i]; &#125; &#125; int[] countArray = new int[max-min+1]; //计数 for(int i = 0; i &lt; array.length; i++)&#123; countArray[array[i]-min]++; &#125; for(int i = 1; i &lt; countArray.length; i++)&#123; //统计变形 countArray[i] += countArray[i-1]; &#125; int[] sortedArray = new int[array.length];//排序 for(int i = array.length-1; i &gt;= 0; i--)&#123; sortedArray[countArray[array[i]-min]-1] = array[i]; countArray[array[i]-min]--; &#125; return sortedArray; &#125; //桶排序 浮点数的计数排序 n public double[] bucketSort(double[] array)&#123; double max = array[0], min = array[0]; for(int i = 1; i &lt; array.length; i++)&#123; if(array[i] &gt; max)&#123; max = array[i]; &#125;if(array[i] &lt; min)&#123; min = array[i]; &#125; &#125; ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList = new ArrayList&lt;LinkedList&lt;Double&gt;&gt;(array.length); for(int i = 0; i &lt; array.length; i++)&#123; bucketList.add(new LinkedList&lt;Double&gt;()); &#125; for(int i = 0; i &lt; array.length; i++)&#123; int num = (int)((array[i] - min) * (array.length-1)/(max-min)); bucketList.get(num).add(array[i]); &#125; for(int i = 0; i &lt; bucketList.size(); i++)&#123; Collections.sort(bucketList.get(i)); &#125; double[] sortedArray = new double[array.length]; int index = 0; for(LinkedList&lt;Double&gt; list: bucketList)&#123; for(double element : list)&#123; sortedArray[index++] = element; &#125; &#125; return sortedArray; &#125; //二分查找 public int biSearch(int[] array, int a)&#123; int left = 0, right = array.length-1; int mid = 0; while(left &lt;= right)&#123; mid = (left+right)/2; if(array[mid] == a)&#123; //找到元素 return mid+1; &#125;else if(array[mid] &lt; a)&#123; //向右查找 left = mid+1; &#125;else&#123; //向左查找 right = mid-1; &#125; &#125; return -1; //未找到元素 &#125; //判断链表有环 public boolean isCycle(ListNode head)&#123; ListNode fast = head, slow = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if(fast == slow)&#123; //首次相遇后，计算步数，当再次相遇时获得环长 //首次相遇后，slow指向头结点，再次相遇节点为入环节点 return true; &#125; &#125; return false; &#125; //最小栈实现 class MinStack&#123; private Stack&lt;Integer&gt; stack = new Stack(); private Stack&lt;Integer&gt; minStack = new Stack(); public void push(int element)&#123; stack.push(element); if(minStack.isEmpty() || element &lt;= minStack.peek())&#123; minStack.push(element); &#125; &#125; public Integer pop()&#123; if(stack.peek().equals(minStack.peek()))&#123; minStack.pop(); &#125; return stack.pop(); &#125; public int getMin() throw Exception&#123; if(stack.isEmpty())&#123; throw new Exception(&quot;stack is empty&quot;); &#125; return minStack.peek(); &#125; &#125; //最大公约数 辗转相除法，欧几里得 public int getGreatestCommonDivisor(int a, int b)&#123; if(a == b) return a; if((a&amp;1) == 0 &amp;&amp; (b&amp;1) == 0) return getGreatestCommonDivisor(a&gt;&gt;1, b&gt;&gt;1); else if((a&amp;1) == 0 &amp;&amp; (b&amp;1) != 0) return getGreatestCommonDivisor(a&gt;&gt;1, b); else if((a&amp;1) != 0 &amp;&amp; (b&amp;1) == 0) return getGreatestCommonDivisor(a, b&gt;&gt;1); else&#123; int big = a&gt;b ? a:b; int small = a&lt;b ? a:b; return getGreatestCommonDivisor(big-small, small); &#125; &#125; //判定数为二次幂 public boolean isPowOf2(int num)&#123; return (num &amp; num-1) == 0; &#125; //无序数组排序后的最大相邻差 桶排序 private class Bucket&#123; Integer max; Integer min; &#125; public int gerMaxSort(int[] array)&#123; int max = array[0]; int min = array[0]; for(int i = 1; i &lt; array.length; i++)&#123; if(array[i] &gt; max)&#123; max =array[i]; if(array[i] &lt; min) min = array[i]; &#125; &#125; if(max-min == 0) return 0; Bucket[] buckets = new Bucket[array.length]; for(int i = 0; i &lt; array.length; i++)&#123; buckets[i] = new Bucket(); int index = ((array[i]-min)*(array.length-1)/(max=min)); if(buckets[index].min == null || buckets[index].min &gt; array[i]) buckets[index],min = array[i]; if(buckets[index].max == null || buckets[index].max &lt; array[i]) buckets[index].max = array[i]; &#125; int leftMax= buckets[0].max, maxDistance = 0; for(int i = 1; i &lt; buckets.length; i++)&#123; if(buckets[i].min == null) continue; if(buckets[i].min-leftMax &gt; maxDistance) maxDistance = buckets[i].min-leftMax; leftMax = buckets[i].max; &#125; return maxDistance; &#125; //队列实现栈 private Stack&lt;Integer&gt; stackA = new Stack&lt;Integer&gt;(); private Stack&lt;Integer&gt; stackB = new Stack&lt;Integer&gt;(); public void enQueue(int element)&#123; stackA.push(element); &#125; public Integer deQueue()&#123; if(stackB.isEmpty())&#123; while(!stackA.isEmpty())&#123; stackB.push(stackA.pop()); &#125; &#125; return stackB.pop(); &#125; //获得全排列下一个数 public int[] findNearestNumber(int[] number)&#123; //从后向前查看逆序区域，获得区域前一位，数字置换边界 int index = 0; for(int i = number.length-1; i &gt;= 0; i--)&#123; if(number[i] &gt; number[i-1])&#123; index = i; break; &#125; &#125; if(index == 0) return null; //把逆序区域前一位和逆序中刚大于它的数字交换 int[] numberCopy = Arrays.copyOf(numberm number.length); int head = numberCopy[index-1]; for(int i = numberCopy.length-1; i &gt; 0; i--)&#123; if(head &lt; numberCopy[i])&#123; numberCopy[index-1] = numb[i]; numberCopy[i] = head; break; &#125; &#125; //把原来的逆序区域转为顺序 for(int i = index, j = numberCopy.length-1; i &lt; j; i++, j--)&#123; int temp = numberCopy[i]; numberCopy[i] = number[j]; numberCopy[j] = temp; &#125; return numberCopy; &#125; //删去k个数字后的最小值 public String removeDigit(String num, int k)&#123; int newLength = num.length()-k; //创建一个栈，接受所有数据 char[] stack = new char[num.length()]; int top = 0; for(int i = 0; i&lt; num.length(); i++)&#123; char c = num.charAt(i); //当栈顶数字大于遍历到的当前数字时，栈顶数字出栈 while(top &gt; 0 &amp;&amp; stack[top-1] &gt; c &amp;&amp; k &gt; 0)&#123; top --; k--; &#125; stack[top++] = c; &#125; //找到栈中第一个非零数字的位置，构建新的整数字符串 int offset = 0; while(offset &lt; newLength &amp;&amp; stack[offset] == &#39;0&#39;)&#123; offset++; &#125; return offset == newLength ? &quot;0&quot; : new String(stack, offset, newLength-offset); &#125; //大数相加 public String bigBumberSum(String a, String b)&#123; int maxLength = a.length()&gt;b.length()&gt; a.length(): b.length(); int[] array = new int[maxLength+1]; for(int i = 0; i &lt; array.length; i++)&#123; int temp = array[i]; if(a.length()-1-i &gt;= 0) temp += a.charAt(a.length()-1-i)-&#39;0&#39;; if(b.length()-1-i &gt;= 0) temp += b.charAt(b.length()-1-i)-&#39;0&#39;; if(temp &gt;= 10)&#123; temp = temp-10; array[i+1] = 1; &#125; array[i] = temp; &#125; StringBuilder ans = new StringBuilder(); boolean findFirst = false; for(int i = array.length-1; i &gt;= 0; i--)&#123; if(!findFirst)&#123; if(array[i] == 0)&#123; continue; &#125; findFirst = true; &#125; ans.append(array[i]); &#125; return ans.toString(); &#125; //求解金矿 背包问题 //工人数量，金矿开采需人工数，金矿储量 public int getBestGoldMining(int w, int[] p, int[] g)&#123; int[][] result = new int[g.length+1][w+1]; for(int i = 1; i &lt;= g.length; i++)&#123; for(int j = 1; j &lt;= w; j++)&#123; if(j &lt; p[i-1]) result[i][j] = result[i-1][j]; else result[i][j] = Math.max(result[i-1][j], result[i-1][j-p[i-1]]+g[i-1]); &#125; &#125; return result[g.length][w]; &#125; //全排列中缺失的数据 分治 public int[] findLostNum(int[] array)&#123; int[] result = new int[2]; int xor = 0; for(int i = 0; i &lt; array.length; i++)&#123; xor ^= array[i]; &#125; if(xor == 0) return null; int separator = 1; while(0 == (xor &amp; separator))&#123; separator &lt;&lt;= 1; &#125; for(int i = 0; i &lt; array.length; i++)&#123; if(0 == (array[i] &amp; separator)) result[0] ^= array[i]; else result[1] ^= array[i]; &#125; return result; &#125; //LRU缓存 最近最少使用 class Node&#123; Node(String key, String value)&#123; this.key = key;this.value = value; &#125; public Node pre; public Node next; public String key; public String value; &#125; private Node head, end; private int limit;//缓存存储上限 private HashMap&lt;String, Node&gt; hashMap; public LRUCache(int limit)&#123; this.limit = limit; hashMap = new HashMap(); &#125; public get(String key)&#123; Node node = hashMap.get(key); if(node == null) return null; refreshNode(node); return node.value; &#125; public void put(String key, String value)&#123; Node node = hashMap.get(key); if(node == null)&#123; if(hashMap.size() &gt;= limit)&#123; String oldkey =removeNode(head); hashMap.remove(oldkey); &#125; node = new Node(key, value); addNode(node); hashMap.put(key, node); &#125;else&#123; node.value = value; refreshNode(node); &#125; &#125; public void remove(String key)&#123; Node node = hashMap.get(key); removeNode(node); hashMap.remove(key); &#125; private void refreshNode(Node node)&#123; //更新使用状态 if(node == end) return; removeNode(node); addNode(node); &#125; private String removeNode(Node node)&#123; if(head == node &amp;&amp; end == node)&#123; //只有一个节点 head = null; end = null; &#125;else if(node == end)&#123; end = end.pre; end.next = null; &#125;else if(node == head)&#123; head = head.next; head.pre = null; &#125;else&#123; node.pre,next = node.next; node.next.pre = node.pre; &#125; return node.key; &#125; private void addNode(Node node)&#123; //添加数据到链表尾部 if(end != null)&#123; end.next = node; node.pre = en; node.next = null; &#125; end = node; if(head == null)&#123; head = node; &#125; &#125; //A星寻路算法 public final int[][] MAZE&#123; &#123;0,0,0,0,0,0,0&#125;, &#123;0,0,0,1,0,0,0&#125;, &#123;0,0,0,1,0,0,0&#125;, &#123;0,0,0,1,0,0,0&#125;, &#123;0,0,0,0,0,0,0&#125;, &#125;; class Grid&#123; public int x, y, f, g, h; public Grid parent; public Grid(int x, int y)&#123; this.x = x; this.y = y; &#125; public void initGrid(Grid parent, Grid end)&#123; this.parent = parent; if(parent != null)&#123; this.g = parent.g+1; &#125;else&#123; this.g = 1; &#125; this.h = Math.abs(this.x-end.x)+Math.abs(this.y-end.y); this.f = this.g+this.h; &#125; &#125; public Grid aStartSearch(Grid start, Grid end)&#123; ArrayList&lt;Grid&gt; openList = new ArrayList(); //可前进位置 ArrayList&lt;Grid&gt; closeList = new ArrayList(); //已走过位置 openList.add(start); while(openList.size() &gt; 0)&#123; Grid currentGrid = findMinGrid(openList); openList.remove(currentGrid); closeList.add(currentGrid); List&lt;Grid&gt; neighbors = findNeighbors(currentGrid, openList,closeList); for(Grid grid : neighbors)&#123; if(!openList.contains(grid))&#123; grid.initGrid(currentGrid, end); openList.add(grid); &#125; if(grid.x == end.x &amp;&amp; grid.y = end.y)&#123; //如果终点在openlist 直接返回终点 return grid; &#125; &#125; &#125; return null; &#125; private Grid findMinGrid(ArrayList&lt;Grid&gt; openList)&#123; Grid tempGrid = openList.get(0); for(Grid grid: openList)&#123; if(grid.f &lt; tempGrid.f) tempGrid = grid; &#125; return tempGrid; &#125; private ArrayList&lt;Grid&gt; findNeighbors(Grid grid, List&lt;Grid&gt; openList, List&lt;Grid&gt; closeList)&#123; ArrayList&lt;Grid&gt; gridlist = new ArrayList(); if(isValidGrid(grid.x, grid.y-1, openList, closeList)) gridlist.add(new Grid(grid.x, grid.y-1)); if(isValidGrid(grid.x, grid.y+1, openList, closeList)) gridlist.add(new Grid(grid.x, grid.y+1)); if(isValidGrid(grid.x-1, grid.y, openList, closeList)) gridlist.add(new Grid(grid.x-1, grid.y)); if(isValidGrid(grid.x+1, grid.y, openList, closeList)) gridlist.add(new Grid(grid.x+1, grid.y)); return gridlist; &#125; private boolean isValidGrid(int x,int y, List&lt;Grid&gt; openList, List&lt;Grid&gt; closeList)&#123; if(x &lt; 0 || x &gt;= MAZE.length || y &lt; 0 || y &gt;= MAZE[0].length) return false; if(MAZE[x][y] == 1) //有障碍 return false; if(containsGrid(openList, x, y) || containsGrid(closeList, x, y)) return false; return true; &#125; private boolean containsGrid(List&lt;Grid&gt; grids, int x, int y)&#123; for(Grid n: grids)&#123; if(n.x == x &amp;&amp; n.y == y)&#123; return true; &#125; &#125; return false; &#125; //红包算法 //二倍均值法 红包=0.01——剩余金额/剩余人数*2-0.01 public List&lt;integer&gt; divideRedPackage(Integer totalAmount, Integer totalPeopleNum)&#123; List&lt;Integer&gt; amountList = new ArrayList&lt;Integer&gt;(); Integer restAmount = totalAmount; Integer restPeoPleNum = totalPeopleNum; Random random = new Random(); for(int i = 0; i &lt; totalPeopleNum-1; i++)&#123; int amount = random.nextInt(restAmount/restPeoPleNum*2-1)+1; restAmount -= amount; restPeoPleNum--; amountList.add(amount); &#125; amountList.add(restAmount); return amountList; &#125; &#125; 手撕代码反转链表```java public ListNode ReverseList(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode p = null; ListNode q = null; while(head != null)&#123; //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre //如此就可以做到反转链表的效果 //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂 q = head.next; //保存完next，就可以让head从指向next变成指向pre了，代码如下 head.next = p; //head指向pre后，就继续依次反转下一个节点 //让pre，head，next依次向后移动一个节点，继续下一次的指针反转 p = head; head = q; &#125; return p; &#125; ``` 三十个人围成一圈，数到5退出，求最后一个退出的```java ``` 矩阵蛇形遍历```java public static void way(int n)&#123; int[][] arry = new int[n][n]; for(int i = 0; i &lt; n; i++)&#123; //初始化 for(int j = 0; j &lt; n; j++)&#123; arry[i][j] = (i-1)*n+j+1; &#125; &#125; int i = 0, j = 0; StringBuilder sb = new StringBuilder(); sb.append(arry[0][0]+&quot; &quot;); //第一个元素 boolean isDown = false; //判断是自上而下还是自下而上，默认自上而下 while(i &lt; n &amp;&amp; j &lt; n)&#123; if(i+1 == n &amp;&amp; j+1 == n)&#123; //结束跳出 break; &#125; if(i-1 &lt; 0|| i+1 == n)&#123; //右 sb.append(arry[i][++j]+&quot; &quot;); isDown = false; &#125;else if(j-1 &lt; 0 || j+1 == n)&#123; //下 sb.append(arry[++i][j]+&quot; &quot;); isDown = true; &#125;else&#123; if(isDown)&#123; sb.append(arry[++i][++j]+&quot; &quot;); &#125;else&#123; sb.append(arry[--i][--j]+&quot; &quot;); &#125; &#125; &#125; System.out.println(sb); &#125; ```","categories":[],"tags":[{"name":"language","slug":"language","permalink":"https://jacksonsheep.github.io/tags/language/"},{"name":"java","slug":"java","permalink":"https://jacksonsheep.github.io/tags/java/"}]},{"title":"compute-network","slug":"network","date":"2022-07-05T16:00:00.000Z","updated":"2024-02-14T02:57:02.554Z","comments":true,"path":"2022/07/06/network/","link":"","permalink":"https://jacksonsheep.github.io/2022/07/06/network/","excerpt":"","text":"计算机网络三次握手，四次挥手 第一次握手：建立连接时，客户端发送syn包（syn&#x3D;x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack&#x3D;x+1），同时自己也发送一个SYN包（syn&#x3D;y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 原文链接 OSI七层架构 网络模型 网络协议 功能说明 应用层 HTTP,FTP,SMTP 表示层 TelNet 会话层 DNS 传输层 TCP,UDP 网络层 IP 数据链路层 物理层 IEEE 802.1A 物理层：物理设备标准，模数转换，（网线，光纤）bit 数据链路层：数据MAC封装和解封，（设备交换机），帧 网络层：ip封装和解封，（路由器），数据报 传输层：传输数据协议和端口（tcp， udp）,报文段 会话层：建立数据传输通路，系统发起会话和接受会话请求 表示层：数据加密解密，压缩，形成视频，图片，音频 应用层：终端应用，（虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。）报文 常用协议 【C ：客户端；S：服务端】 tcp 三次握手（C-S,S-C,C-S）:第三次握手是可以携带数据的，前两次握手是不可以携带数据的; 【三次握手原因】防止历史连接初始化了连接，同步双方初始序列号，避免资源浪费 一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN状态 客户端会随机初始化序号（ client_isn ），将此序号置于 TCP 首部的「序号」字段中，同时把SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处 服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（ server_isn ），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1 , 接着把 SYN 和 ACK 标志位置为 1 。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。 四次挥手（C-S,S-C,C-S,S-C） 客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN报文，之后客户端进入 FIN_WAIT_1 状态。 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。 客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。 等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态 服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭。 客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。 分片：MTU分片和MCC分片 ？ 流量控制：滑动窗口：窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。 拥塞控制：【重传机制】 超时重传：重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据【数据包丢失，确认应答丢失】，超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。 快速重传机制：它不以时间为驱动，而是以数据驱动重传。 SACK：在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。 D-SACK:使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。 全连接队列，半连接队列 arp：通过ip地址查找到对应的mac地址（rarp：根据mac地址查找对应ip地址） 主机会通过广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。 dhcp: 自动配置ip地址 客户端首先发起 DHCP 发现报文（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。 DHCP 服务器收到 DHCP 发现报文时，用 DHCP 提供报文（DHCP OFFER） 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。 客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 DHCP 请求报文（DHCP REQUEST进行响应，回显配置的参数。 最后，服务端用 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数。 dns：通过域名逐级查找对应ip地址（根服务器，顶级域名服务器.com，权威服务器.server.com） 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归.com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。” 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP地址吗？” 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。 8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。 nat：网络地址转换（私有ip转为公有ip） ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。 常用设备 交换机：两层网络设备，端口无mac地址（包含对应的MAC-端口映射表：根据目的MAC查找对应端口，如未查到，发送数据包到除源端口外的所有端口，获得响应后记录到表中） 路由器：三层网络设备，端口含ip，mac地址","categories":[],"tags":[{"name":"basic","slug":"basic","permalink":"https://jacksonsheep.github.io/tags/basic/"},{"name":"network","slug":"network","permalink":"https://jacksonsheep.github.io/tags/network/"}]},{"title":"software-manage","slug":"soft-manage","date":"2022-07-05T16:00:00.000Z","updated":"2024-02-14T02:57:02.558Z","comments":true,"path":"2022/07/06/soft-manage/","link":"","permalink":"https://jacksonsheep.github.io/2022/07/06/soft-manage/","excerpt":"","text":"软件工程整体流程概述概要设计详细设计测试单元测试集成测试","categories":[],"tags":[{"name":"basic","slug":"basic","permalink":"https://jacksonsheep.github.io/tags/basic/"},{"name":"manage","slug":"manage","permalink":"https://jacksonsheep.github.io/tags/manage/"}]},{"title":"linux","slug":"linux","date":"2022-07-05T16:00:00.000Z","updated":"2024-02-14T02:57:02.554Z","comments":true,"path":"2022/07/06/linux/","link":"","permalink":"https://jacksonsheep.github.io/2022/07/06/linux/","excerpt":"","text":"操作系统分页，分段区别分页和分段有许多相似之处,比如两者都不要求作业连续存放.但在概念上两者完全不同,主要表现在以下几个方面:[原文链接](https://blog.csdn.net/wangrunmin/article/details/7967293?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161931624016780357247739%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161931624016780357247739&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-7967293.first_rank_v2_pc_rank_v29&amp;utm_term=%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5) (1)页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要. (2)页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分. (3)分页的作业地址空间是一维的.分段的地址空间是二维的. 线程，进程进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程一般由程序，数据集合和进程控制块三部分组成 线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位 一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)[原文链接](https://www.cnblogs.com/qianqiannian/p/7010909.html) 死锁，银行家算法- 产生条件：（1） **互斥条件**：一个资源每次只能被一个进程使用。（2） **占有且等待**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3）**不可强行占有**:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） **循环等待条件**:若干进程之间形成一种头尾相接的循环等待资源关系。 - 处理死锁 - 死锁预防：通过设置某些限制条件，去破坏死锁的四个条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。 - 死锁避免：允许前三个必要条件，但通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。**银行家算法** - 死锁检测：不须实现采取任何限制性措施，而是允许系统在运行过程发生死锁，但可通过系统设置的检测机构及时检测出死锁的发生，并精确地确定于死锁相关的进程和资源，然后采取适当的措施，从系统中将已发生的死锁清除掉。 - 死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。死锁检测盒解除有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。 [原文链接](https://blog.csdn.net/qq_42883292/article/details/106151240) 常识 系统启动：1. 内核引导2. 运行init3. 系统初始化4. 建立终端5. 用户登录系统 系统目录： &#x2F;bin：是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 &#x2F;boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 &#x2F;dev ：是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 &#x2F;etc：是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 &#x2F;home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。 &#x2F;lib：是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 &#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 &#x2F;media：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 &#x2F;mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。 &#x2F;opt：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 &#x2F;proc：proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件， &#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。 &#x2F;sbin：就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。 &#x2F;selinux： 这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 &#x2F;srv： 该目录存放一些服务启动之后需要提取的数据。 &#x2F;sys：这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 &#x2F;tmp：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。 &#x2F;usr： usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 &#x2F;usr&#x2F;bin：系统用户使用的应用程序。 &#x2F;usr&#x2F;sbin：超级用户使用的比较高级的管理程序和系统守护程序。 &#x2F;usr&#x2F;src：内核源代码默认的放置目录。 &#x2F;var：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 &#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。 指令权限 chown：修改所属用户和组 chmod：修改用户权限 ll &#x2F; ls -l 展示文件权限 【d r-x r-x r-x】 第0位，文件类型【d：目录，-：文件，l：链接文件，b：装置文件中可供存储的接口设备（可随机存储装置），c：装置文件中串行端口设备（键盘等一次性读取装置）】 第1-3位,第4-6位,第7-9位分别为属主（文件所有者）权限，属组（所有者的同组用户）权限，其他用户权限 第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 - 字符表示，则没有读权限； 第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 - 字符表示没有写权限 第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 - 字符表示，则没有执行权限。 文件目录：使用 man [命令] 来查看各个命令的使用文档 ls（英文全拼：list files）: 列出目录及文件名 -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) cd [相对路径或绝对路径]（英文全拼：change directory）：切换目录 pwd [-P]（英文全拼：print work directory）：显示目前的目录 -P ：显示出确实的路径，而非使用连结 (link) 路径。 mkdir [-mp] 目录名称（英文全拼：make directory）：创建一个新的目录 -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ rmdir [-p] 目录名称（英文全拼：remove directory）：删除一个空的目录 -p ：连同上一级『空的』目录也一起删除 cp（英文全拼：copy file）: 复制文件或目录 -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身； -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -r：递归持续复制，用於目录的复制行为；(常用) -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ rm [-fir] 文件或目录（英文全拼：remove）: 删除文件或目录 -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称 -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 文件内容查看 cat [-AbEnTv] 由第一行开始显示文件内容 -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl [-bnw] 文件 显示的时候，顺道输出行号！ -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种： -n ln ：行号在荧幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 more 一页一页的显示文件内容。以下是指令运行时可进行操作 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； &#x2F;字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； &#x2F;字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！) N ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！) q ：离开 less 这个程序； head [-n number] 文件 只看头几行 -n ：后面接数字，代表显示几行的意思 tail [-n number] 文件 只看尾巴几行 -n ：后面接数字，代表显示几行的意思 -f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测 用户和用户组管理 useradd 选项 用户名：添加新的用户账号 -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 userdel 选项 用户名：删除一个已有的用户账号 -r 把用户的主目录一起删除。 usermod 选项 用户名：修改用户账号，根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等 passwd 选项 用户名：指定和修改用户口令 -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 groupadd 选项 用户组：增加一个新的用户组 -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 groupdel 用户组：删除一个已有的用户组 groupmod 选项 用户组：修改用户组的属性 -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 newgrp 用户组：当前用户切换到用户组【用户存在于该用户组中】 重要文件 etc&#x2F;passwd：账户信息 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell etc&#x2F;group：用户组信息 组名:口令:组标识号:组内用户列表 磁盘管理 df [-ahikHTm] [目录或文件名]（英文全称：disk full）：列出文件系统的整体磁盘使用量 -a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统； -k ：以 KBytes 的容量显示各文件系统； -m ：以 MBytes 的容量显示各文件系统； -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； -H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式； -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出； -i ：不用硬盘容量，而以 inode 的数量来显示 du [-ahskm] 文件或目录名称（英文全称：disk used）：检查磁盘空间使用量 a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G&#x2F;M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； fdisk [-l] 装置名称：用于磁盘分区 -l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。 mkfs [-t 文件系统格式] 装置文件名 磁盘格式化 -t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效) fsck [-t 文件系统] [-ACay] 装置名称 磁盘检验，检查和维护不一致的文件系统 -t : 给定档案系统的型式，若在 &#x2F;etc&#x2F;fstab 中已有定义或 kernel 本身已支援的则不需加上此参数 -s : 依序一个一个地执行 fsck 的指令来检查 -A : 对&#x2F;etc&#x2F;fstab 中所有列出来的 分区（partition）做检查 -C : 显示完整的检查进度 -d : 打印出 e2fsck 的 debug 结果 -p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行 -R : 同时有 -A 条件时，省略 &#x2F; 不检查 -V : 详细显示模式 -a : 如果检查有错则自动修复 -r : 如果检查有错则由使用者回答是否修复 -y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。 mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 磁盘挂载 umount [-fn] 装置文件名或挂载点 磁盘卸载 -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下； -n ：不升级 &#x2F;etc&#x2F;mtab 情况下卸除。 安装命令 yum [options] [command] [package …]：options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 “yes”），-q（不显示安装的过程）等等; command：要进行的操作; package：安装的包名。 列出所有可更新的软件清单命令：yum check-update 更新所有软件命令：yum update 仅安装指定的软件命令：yum install 仅更新指定的软件命令：yum update 列出所有可安裝的软件清单命令：yum list 删除软件包命令：yum remove 查找软件包命令：yum search 清除缓存命令: yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers yum clean oldheaders: 清除缓存目录下旧的 headers yum clean, yum clean all (&#x3D; yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers apt [options] [command] [package …]：options：可选，选项包括 -h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等; command：要进行的操作; package：安装的包名。 列出所有可更新的软件清单命令：sudo apt update 升级软件包：sudo apt upgrade 列出可更新的软件包及版本信息：apt list –upgradeable 升级软件包，升级前先删除需要更新软件包：sudo apt full-upgrade 安装指定的软件命令：sudo apt install 安装多个软件包：sudo apt install 更新指定的软件命令：sudo apt update 显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：sudo apt show 删除软件包命令：sudo apt remove 清理不再使用的依赖和库文件: sudo apt autoremove 移除软件包及配置文件: sudo apt purge 查找软件包命令： sudo apt search 列出所有已安装的包：apt list –installed 列出所有已安装的包的版本信息：apt list –all-versions Linux(CenterOS) 命令防火墙 开放80 firewall-cmd –zone&#x3D;public –add-port&#x3D;80&#x2F;tcp –permanent – zone #作用域 – add-port&#x3D;80&#x2F;tcp #添加端口，格式为：端口&#x2F;通讯协议 – permanent #永久生效，没有此参数重启后失效 关闭80 firewall-cmd –zone&#x3D;public –remove-port&#x3D;80&#x2F;tcp –permanent 重启防火墙 ： firewall-cmd –reload 查询哪些端口开放 ：firewall-cmd –list-port 关闭防火墙 ：systemctl stop firewalld.service 禁止开机启动防火墙 ： systemctl disable firewalld.service 允许开机启动防火墙 ：systemctl enable firewalld.service 查看防火墙状态 ：firewall-cmd –state service安装上传下载插件（rz,sz）yum install lrzsz解压文件tar -zxvf 文件名 jdk:yum -y list java*yum install java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-devel.x86_64 mysql:[https://blog.csdn.net/wohiusdashi/article/details/89358071]wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpmrpm -ivh mysql57-community-release-el7-9.noarch.rpmyum install mysql-serversystemctl start mysqldgrep ‘temporary password’ &#x2F;var&#x2F;log&#x2F;mysqld.logALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘@abcd123456’;","categories":[],"tags":[{"name":"basic","slug":"basic","permalink":"https://jacksonsheep.github.io/tags/basic/"},{"name":"system","slug":"system","permalink":"https://jacksonsheep.github.io/tags/system/"}]},{"title":"cephfs","slug":"storage/cephfs","date":"2022-07-05T16:00:00.000Z","updated":"2024-02-14T02:57:02.558Z","comments":true,"path":"2022/07/06/storage/cephfs/","link":"","permalink":"https://jacksonsheep.github.io/2022/07/06/storage/cephfs/","excerpt":"","text":"ceph 文件存储总结组织结构 Monitor ceph 管理节点，保存并维护各个map信息和权限，日志等集群管理内容 MDS 元数据服务器，创建，修改，重命名，删除文件，文件夹等服务的提供者，同时包含挂载和卸载部分。 MDSDaemon mds守护进程，mds创建时通过它来引导其他部分的启动和正常执行内容 MDSRank&#x2F;MDRankDispatcher, mds的主要消息分发器，和Monitor等集群通信的通过Beacon分发器使用Monc传递消息 Server, 重点业务执行部分，元数据的处理大多位于此 MDCache。 mds缓存处理，对业务快速响应的支持 MDLog， mds日志操作，每个元数据操作先写入日志，确保数据不丢失之后通过日志下刷落盘持久化。 OSD 实际存储组件，存储数据和元数据的磁盘管理，底层数据存储原理位于此 rados 一个文件对应多个对象，一个文件夹默认对应一个对象，默认对象大小为4M，超出部分存入下一个对象 pg， 每个对象对应一个pg，映射关系通过hash完成 osd， 每个pg对应多个osd，映射关系为crush算法。osd直接控制每个对象的数据块存储在磁盘的位置，以及日志的存储等内容。 源码分析mkdir Server–handle_client_mkdir() 获取或创建当前父级目录的信息，并创建Dentry和父级目录的Dir相连接 创建空Inode，并和Dentry连接，放入projected队列中 创建或查找对应dir，并和inode连接 early replay 写入日志，EUpdate 回复客户端，并将inode移出projected队列 ceph-fuse client 向 Monitor 权限认证并订阅monmap，fsmap，osdmap client 向 mds 发送挂载申请，并获取挂载目录 的inode信息 client 内核操作，将inode信息更新到vfs中，方便后续使用 mds 状态切换1.","categories":[],"tags":[{"name":"storage","slug":"storage","permalink":"https://jacksonsheep.github.io/tags/storage/"},{"name":"ceph","slug":"ceph","permalink":"https://jacksonsheep.github.io/tags/ceph/"},{"name":"client","slug":"client","permalink":"https://jacksonsheep.github.io/tags/client/"}]},{"title":"disk-manage","slug":"storage/disk","date":"2022-07-05T16:00:00.000Z","updated":"2024-02-14T02:57:02.558Z","comments":true,"path":"2022/07/06/storage/disk/","link":"","permalink":"https://jacksonsheep.github.io/2022/07/06/storage/disk/","excerpt":"","text":"磁盘分析协议 scsi raid 磁盘固态磁盘机械磁盘","categories":[],"tags":[{"name":"basic","slug":"basic","permalink":"https://jacksonsheep.github.io/tags/basic/"},{"name":"storage","slug":"storage","permalink":"https://jacksonsheep.github.io/tags/storage/"}]},{"title":"tool","slug":"tools/tools","date":"2022-07-05T16:00:00.000Z","updated":"2024-02-14T02:57:02.558Z","comments":true,"path":"2022/07/06/tools/tools/","link":"","permalink":"https://jacksonsheep.github.io/2022/07/06/tools/tools/","excerpt":"","text":"git 命令：整体流程，先pull获取最新代码，合并后提交本地，之后push git init 初始化git本地仓库 git log 展示提交日志 git log –pretty&#x3D;oneline 线性展示日志 git log –graph 以树形展示日志 git reflog 展示操作日志 git reset –soft HEAD^ 返回上次提交 git rm –cached &lt;file&gt; 从暂存区删除文件，但不改变文件区 git status 当前状态 git commit -m “note” 提交代码 git remote 查看远程状态 git remote -v 显示详细远程状态 git push origin [master&#x2F;dev] 推送分支 git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取分支 git clone &#103;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#x6d;:…&#x2F;.git 从远程克隆项目 git rebase 变基，将修改前的基础转换为最新状态 git branch [name] 创建分支 git checkout [name] 切换分支 git branch 查看分支 git merge [name] 合并分支 git merge –no-ff -m “merge with no-ff” dev 合并生成新的提交，当分支删除，信息仍然存在 git branch -d [name] 删除分支 git branch -D [name] 强行删除分支 git stash 储存当前分支状态 git stash list 查看可回复状态 git stash apply 回复+ git shash drop 删除 git stash pop 回复并删除 git cherry-pick [number] 将master修改的bug复制到当前分支 git tag 查看所有标签 git tag [name] 打开新的标签， 状态为当前状态 git tag [name] [number] 提交number对应状态的标签name git show [name] 显示标签内容 git tag -d [name] 删除标签 git push origin :refs&#x2F;tags&#x2F;[name] 删除远程标签 idea 常用函数 @deprecated 该类已过时 &#x2F;&#x2F;todo 后期可添加内容 常用快捷键 http：get,post,delete,put用http Tools调试 相机图标截取当前线程状态 ：查看在运行中的线程 打断点，调试 找到实现 ctrl+点击 或者 前方图标 ctrl+shift+&#x2F; 区块注释 Alt+Insert 产生构造方法、getter&#x2F;setter等方法 Ctrl+R 替换 Shift+Enter 在当前行的下方开始新行 Ctrl+Alt+Enter 在当前行上方插入新行 Ctrl + Alt + b 转到实现 Ctrl+Alt+L 格式化代码 ctrl+Q 查看方法说明 Ctrl+D 复制光标所在行的内容，插入光标位置下面 psvn main sout 默认输出 itar for遍历 vscode ctrl+E oepn folder explose notepad ctrl d 复制当前行 ctrl l 删除当前行 vimyy 复制光标当前行n 粘贴剪切板的行到光标位置 nanolinux operatedeb 其余文件，安装后覆盖到根目录 DEBIAN control Package 程序名称 中间不能有空格 Version 软件版本 Description 程序说明 Section 软件类别 utils, net, mail, text, x11 Priority 软件对于系统的重要程度 required, standard, optional, extra等； Essential 是否是系统最基本的软件包 yes&#x2F;no，若为yes,则不允许卸载（除非强制性卸载） Architecture 软件所支持的平台架构 i386, amd64, m68k, sparc, alpha, powerpc等 Source 软件包的源代码名称 Depends 软件所依赖的其他软件包和库文件 若依赖多个软件包和库文件，采用逗号隔开 Pre-Depends 软件安装前必须安装、 配置依赖性的软件包和库文件 常用于必须的预运行脚本需求 Recommends 推荐安装的其他软件包和库文件 Suggests 建议安装的其他软件包和库文件 postinst(postinstallation) 负责完成安装包时的配置工作。如新安装或升级的软件重启服务。软件安装完后，执行该Shell脚本，一般用来配置软件执行环境，必须以“#!&#x2F;bin&#x2F;sh”为首行。 postrm(postremove) 负责修改软件包链接或文件关联，或删除由它创建的文件。软件卸载后，执行该Shell脚本，一般作为清理收尾工作，必须以“#!&#x2F;bin&#x2F;sh”为首行 preinst(preinstallation) 在Deb包文件解包之前（即软件安装前），将会运行该脚本。可以停止作用于待升级软件包的服务，直到软件包安装或升级完成。 prerm(preremove) 该脚本负责停止与软件包相关联的daemon服务。它在删除软件包关联文件之前执行。 copyright(版权) changlog(修订记录) conffiles dpkg dkpg -b . mydeb.deb 打包 dkpg -i mydeb.deb 装包（添加 –force-depends 强制安装） dpkg –unpack mydeb.deb 解压包，不安装 dpkg -c mydeb.deb 查看deb包文件内容 dpkg –info mydeb.deb 查看deb包信息 dpkg -L mydeb 列出deb包关联的文件 dpkg -s|–status mydeb 查看deb包是否安装，查看安装信息 dpkg -r mydeb 卸载deb包，保留配置文件 dpkg -P|–purge mydeb 删除deb包，删除配置文件 apt-get install .&#x2F;mydeb.deb 安装依赖包，安装deb包~","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://jacksonsheep.github.io/tags/tool/"},{"name":"git","slug":"git","permalink":"https://jacksonsheep.github.io/tags/git/"}]}],"categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://jacksonsheep.github.io/tags/tool/"},{"name":"termux","slug":"termux","permalink":"https://jacksonsheep.github.io/tags/termux/"},{"name":"ssh","slug":"ssh","permalink":"https://jacksonsheep.github.io/tags/ssh/"},{"name":"basic","slug":"basic","permalink":"https://jacksonsheep.github.io/tags/basic/"},{"name":"database","slug":"database","permalink":"https://jacksonsheep.github.io/tags/database/"},{"name":"manage","slug":"manage","permalink":"https://jacksonsheep.github.io/tags/manage/"},{"name":"language","slug":"language","permalink":"https://jacksonsheep.github.io/tags/language/"},{"name":"java","slug":"java","permalink":"https://jacksonsheep.github.io/tags/java/"},{"name":"network","slug":"network","permalink":"https://jacksonsheep.github.io/tags/network/"},{"name":"system","slug":"system","permalink":"https://jacksonsheep.github.io/tags/system/"},{"name":"storage","slug":"storage","permalink":"https://jacksonsheep.github.io/tags/storage/"},{"name":"ceph","slug":"ceph","permalink":"https://jacksonsheep.github.io/tags/ceph/"},{"name":"client","slug":"client","permalink":"https://jacksonsheep.github.io/tags/client/"},{"name":"git","slug":"git","permalink":"https://jacksonsheep.github.io/tags/git/"}]}